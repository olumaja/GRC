using Arm.GrcApi.Modules.IncidentManagement;
using Arm.GrcApi.Modules.InternalControl;
using Arm.GrcApi.Modules.ISMSReporting;
using Arm.GrcApi.Modules.Shared.Helpers;
using Arm.GrcApi.Modules.VulnerabilityManagement;
using Arm.GrcTool.Infrastructure;
using GrcApi.Modules.Shared.Helpers;
using GrcApi.Modules.VulnerabilityManagement;
using Microsoft.EntityFrameworkCore;
using System;

namespace Arm.GrcApi.Modules.ISMSReporting
{
    /*
    * Original Author: Sodiq Quadre
    * Date Created: 07/18/2025
    * Development Group: GRCTools
    * Get Internal Vulnerability Reports Endpoint
    */
    public class GetInternalVulnerabilityReportsEndpoint
    {
        /// <summary>
        /// Get Internal Vulnerability Reports Endpoint
        /// </summary>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="repo"></param>
        /// <param name="currentUserService"></param>
        /// <param name="httpContext"></param>
        /// <param name="pageSize"></param>
        /// <param name="pageNumber"></param>
        /// <param name="isDownload"></param>
        /// <returns></returns>
        public static async Task<IResult> HandleAsync(DateTime? startDate, DateTime? endDate, string? status,
            IRepository<InternalVulnerability> repo, ICurrentUserService currentUserService, IHttpContextAccessor httpContext, int pageSize = 10, int pageNumber = 1, bool isDownload = false)
        {
            try
            {
                if (startDate > endDate)
                    return TypedResults.BadRequest("Oops, EndDate cannot be earlier than StartDate");

                var query = repo.GetContextByConditon(q => q.Id != default ).Include(b => b.VulnerabilityModel)
                                  .OrderByDescending(r => r.CreatedOnUtc);
                if (startDate != null || endDate != null)
                {
                    query = query.Where(d => d.CreatedOnUtc.Date >= startDate.Value.Date && d.CreatedOnUtc.Date <= endDate.Value.Date)
                                  .OrderByDescending(r => r.CreatedOnUtc);
                }

                if (!string.IsNullOrEmpty(status)) 
                {
                    var getstatus = status.ToLower();
                    var statusRecommended = new Dictionary<string, VulnerabilityStatus>
                    {
                     {"resolved", VulnerabilityStatus.Resolved}, {"unresolved", VulnerabilityStatus.UnResolved},
                     {"pending", VulnerabilityStatus.Pending}
                    };

                    if (!statusRecommended.ContainsKey(getstatus))
                        return TypedResults.BadRequest($"Enter one of the following recommended status {string.Join(",", statusRecommended.Keys)}");
                    query = query.Where(d => d.Status == statusRecommended[getstatus])
                                .OrderByDescending(r => r.CreatedOnUtc);
                }

                if (isDownload)
                {
                    var records = query.OrderByDescending(x => x.CreatedOnUtc).ToList().Select(t => new GetVulnerabilityReportResp(
                        AssessmentType: t.VulnerabilityModel.AssessmentType,
                        TitleOfAssessment: t.VulnerabilityModel.TitleOfAssessment,
                        IP: t.IP,
                        DNS: t.DNS,
                        NETBIOS: t.NETBIOS,
                        Vulnerability: t.Vulnerability,
                        Rating: t.Rating,
                        Port: t.Port,
                        Protocol: t.Proptocol,
                        Threat: t.Threat,
                        Impact: t.Impact,
                        Solution: t.Solution,
                        Classification: t.Classification,
                        ActionOwner: t.VulnerabilityModel.ActionOwner,
                        Actionownerunit: t.VulnerabilityModel.ActionOwnerUnit,
                        ProposedEndDate: t.VulnerabilityModel.ProposeEndDate,
                        Status: t.Status.ToString(),
                        ActionOwnerStatus: t.ActionOwnerStatus.ToString(),
                        SupervisorStatus: t.Action.ToString(),
                        ReasonForRejection: t.VulnerabilityModel.ReasonForRejection,
                        ApprovedBy: t.VulnerabilityModel.ApprovedBy,
                        DateApproved: t.VulnerabilityModel.DateApproved,
                        InfosecFeedbackStatus: t.VulnerabilityModel.InfosecFeedbackStatus.ToString(),
                        RequestBy: t.CreatedBy,
                        RequestedDate: t.CreatedOnUtc
                        
                        )).ToList();
                    var excelSheetName = "Vulnerability Management Reports";
                    var columnHeaders = new List<string>
                    {
                        "Assessment Type","Title Of Assessment", "IP", "DNS", "NETBIOS", "Vulnerability", "Rating", "Port", "Protocol", "Threat", "Impact", "Solution", "Classification", "Action Owner",
                        "Action Owner Unit", "Proposed End Date", "Status", "Action Owner Status", "Supervisor Status", "Reason For Rejection", "Approved By", "Date Approved", "Infosec Feedback Status", "Request By", "Requested Date"
                    };

                    var report = ReportDocument.GenerateExcelDocument(excelSheetName, columnHeaders, records);

                    return TypedResults.File(report, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", $"{excelSheetName}{DateTime.Now:yyyyMMddhhmmss}.xlsx");
                }

                const int MaxPageSize = 100, DefaultPageSize = 10, DefaultPageNumber = 1;

                if (pageSize > MaxPageSize)
                    pageSize = MaxPageSize;

                if (pageSize < 1)
                    pageSize = DefaultPageSize;

                if (pageNumber < DefaultPageNumber)
                    pageNumber = DefaultPageNumber;

                var paginatedTasks = Pagination<InternalVulnerability>.Create(query, pageNumber, pageSize);

                var paginationMeta = new PaginationMeta
                    (
                        paginatedTasks.HasNextPage,
                        paginatedTasks.HasPreviousPage,
                        paginatedTasks.CurrentPage,
                        paginatedTasks.PageSize,
                        paginatedTasks.TotalPages,
                        paginatedTasks.TotalCount
                    );

                httpContext.HttpContext.Response.AddPagination(paginationMeta);

                var response = new PaginatedGetInternalVulnerabilityResp(
                    paginationMeta,
                    paginatedTasks.OrderByDescending(x => x.CreatedOnUtc).Select(p => new GetInternalVulnerabilityResponse
                    {
                        InternalVulnerabilityFileId = p.Id,
                        Date = p.VulnerabilityModel.CreatedOnUtc.ToString("MM/dd/yyyy hh:mm tt"),
                        AssessmentType = p.VulnerabilityModel.AssessmentType,
                        AssessmentTitle = p.VulnerabilityModel.TitleOfAssessment,
                        Initiator = p.VulnerabilityModel.CreatedBy,
                        ActionOwner = p.VulnerabilityModel.ActionOwner,
                        Status = p.VulnerabilityModel.VulnerabilityStatus.ToString()
                    }).ToList()
                );

                return TypedResults.Ok(response);
            }
            catch (Exception ex)
            {

                return TypedResults.NotFound("Exception: Vulnerability management record was not found");
            }
        }

    }
}
