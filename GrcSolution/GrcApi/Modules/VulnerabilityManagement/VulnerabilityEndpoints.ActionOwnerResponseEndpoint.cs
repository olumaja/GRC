using Arm.GrcTool.Domain;
using Arm.GrcTool.InfrastruCTOre;
using Arm.GrcTool.Infrastructure;
using GrcApi.Modules.Shared.Helpers;
using GrcApi.Modules.VulnerabilityManagement;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System;
using System.Linq;
using System.Net.Mail;

namespace Arm.GrcApi.Modules.VulnerabilityManagement
{
    public class ActionOwnerEvidenceResponseEndpoint
    {
        /// <summary>
        /// Action owner to submit response
        /// </summary>
        /// <param name="payload"></param>
        /// <param name="internalVulRepo"></param>
        /// <param name="vulneribilityRepo"></param>
        /// <param name="docRepo"></param>
        /// <param name="currentUserService"></param>
        /// <returns></returns>
        public static async Task<IResult> HandleAsync(
            HttpRequest payload, IRepository<InternalVulnerability> internalVulRepo, IRepository<VulnerabilityModel> vulneribilityRepo,
            IRepository<Document> docRepo, IEmailService EmailService, IConfiguration config, ICurrentUserService currentUserService
        )
        {
            var forms = await payload.ReadFormAsync();
            int count = 0;
            var fileTypeAllow = new List<string> { "pdf", "xlsx", "xls", "docx", "jpeg", "png" };
            var statusAllow = new Dictionary<string, VulnerabilityStatus> { 
                { "RESOLVED", VulnerabilityStatus.Resolved }, { "UNRESOLVED", VulnerabilityStatus.UnResolved}
            };
            var evidences = new List<EvidenceDto>();

            while (true)
            {
                var vulnerabilityModelIdKey = $"VulnerabilityModelId{count}";
                var internalVulnerabilityIdKey = $"InternalVulnerabilityId{count}";
                var statusKey = $"Status{count}";
                var classificationKey = $"Classification{count}";
                var evidenceFileKey = $"EvidenceFile{count}";

                if (!forms.ContainsKey(vulnerabilityModelIdKey) || !forms.ContainsKey(internalVulnerabilityIdKey) || !forms.ContainsKey(statusKey))
                    break;

                Guid vulnerabilityModelId;
                Guid internalVulnerabilityId;

                if (!Guid.TryParse(forms[vulnerabilityModelIdKey], out vulnerabilityModelId))
                    return TypedResults.BadRequest($"The vulnerability model id {forms[vulnerabilityModelIdKey]} is not valid");

                if (!Guid.TryParse(forms[internalVulnerabilityIdKey], out internalVulnerabilityId))
                    return TypedResults.BadRequest($"The internal vulnerability id {forms[internalVulnerabilityIdKey]} is not valid");

                var status = forms[statusKey].ToString();
                status = status.ToUpper();

                if (string.IsNullOrWhiteSpace(status) || !statusAllow.ContainsKey(status))
                    return TypedResults.BadRequest("Status can only be Resolved or Unresolved");

                var file = forms.Files.GetFile(evidenceFileKey);

                if (file != null)
                {
                    var fileExtension = Path.GetExtension(file.FileName).Trim('.').ToLower();

                    if (!fileTypeAllow.Contains(fileExtension))
                        return TypedResults.BadRequest($"File types allowed are {string.Join(",", fileTypeAllow)}");
                }

                evidences.Add(new EvidenceDto(
                    VulnerabilityModelId: vulnerabilityModelId,
                    InternalVulnerabilityId: internalVulnerabilityId,
                    Classification: forms[classificationKey],
                    Status: statusAllow[status],
                    Attachment: file
                ));

                count++;
            }

            if (count == 0)
                return TypedResults.BadRequest("No response submitted");

            var vulnerabilty = vulneribilityRepo.GetContextByConditon(v => v.Id == evidences[0].VulnerabilityModelId)
                                                .Include(v => v.InternalVulnerabilities)
                                                .FirstOrDefault();

            if(vulnerabilty is null)
                return TypedResults.NotFound("Record doesnot exist");

            if (vulnerabilty.ActionOwnerEmail.ToLower() != currentUserService.CurrentUserEmail.ToLower())
                return TypedResults.Forbid();

            vulnerabilty.StatusAfterActionOwnerResponse();
            vulnerabilty.SetModifiedBy(currentUserService.CurrentUserFullName);
            vulnerabilty.SetModifiedOnUtc(DateTime.Now);

            var internalVulnerabilities = vulnerabilty.InternalVulnerabilities;

            //Add attachments
            List<Document> attachedFiles = new();

            foreach (var evidence in evidences)
            {
                var index = internalVulnerabilities.FindIndex(v => v.Id == evidence.InternalVulnerabilityId);

                if (index >= 0)
                {
                    internalVulnerabilities[index].UpdateAfterActionOwnerResponse(evidence.Status, evidence.Classification);

                    if (evidence.Attachment != null)
                        attachedFiles.Add(DocumentExtensions.ConvertFormFileToDocument(evidence.Attachment, ModuleType.InfoSecInternalVulnerability, evidence.InternalVulnerabilityId));
                }
            }

            if(attachedFiles.Count > 0)
                await docRepo.AddRangeAsync(attachedFiles);

            await docRepo.SaveChangesAsync();

            #region Send email to the infosec staff      
            DateTime currentMonth = vulnerabilty.CreatedOnUtc;
            string currentMonthFormatted = currentMonth.ToString("MMMM yyyy");
            string subject = $"Internal Vulnerability Assessment for {currentMonthFormatted}";
            var linkToGRCTool = config["EmailConfiguration:linkToGRCTool"];
            string emailTo = vulnerabilty.RequesterEmailAddress;
            string toCC = $"{currentUserService.CurrentUserEmail}," + config["EmailConfiguration:InformationSecurityGroupEmail"];
            string body = $"Dear {vulnerabilty.CreatedBy}, <br><br>This is to notify you that the remediation has been completed for the {currentMonthFormatted} Internal Vulnerability Assessment. <br><br> The necessary changes have been implemented. Kindly log on here and verify <br><br><a href={linkToGRCTool}>GRC link</a>.";
            var logEmailRequest = await EmailService.LogEmailRequestAssync(subject: subject, message: body, ModuleType.InfoSecInternalVulnerability, vulnerabilty.Id, emailTo, toCC);

            #endregion

            return TypedResults.Ok("Response submitted successfully");
        }
    }
}
