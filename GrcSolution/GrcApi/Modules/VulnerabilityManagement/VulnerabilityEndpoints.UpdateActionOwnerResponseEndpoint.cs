using Arm.GrcApi.Modules.AntivirusAssessment;
using Arm.GrcTool.Domain;
using Arm.GrcTool.InfrastruCTOre;
using Arm.GrcTool.Infrastructure;
using GrcApi.Modules.Shared.Helpers;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace Arm.GrcApi.Modules.VulnerabilityManagement
{
    public class UpdateActionOwnerResponseEndpoint
    {
        public static async Task<IResult> HandleAsync(
            UpdateActionownerResponseDto payload, IRepository<InternalVulnerability> internalRepo, IRepository<VulnerabilityModel> vulnerabilityMod,  IRepository<Document> docRepo,
            IEmailService EmailService, IConfiguration config, ICurrentUserService currentUserService 
        )
        {
            var internalVulnerability = internalRepo.GetContextByConditon(i => i.Id == payload.InternalVulnerabilityId && i.Action == VulnerabilityStatus.Rejected)
                                                    .Include(i => i.VulnerabilityModel)
                                                    .FirstOrDefault();

            if(internalVulnerability == null)
                return TypedResults.NotFound("Record not found");

            if(internalVulnerability.VulnerabilityModel.ActionOwnerEmail.ToLower() != currentUserService.CurrentUserEmail.ToLower())
                return TypedResults.Forbid();

            var vulnerabilty = vulnerabilityMod.GetContextByConditon(v => v.Id == internalVulnerability.VulnerabilityModelId)
                .Include(i => i.InternalVulnerabilities).FirstOrDefault();

            if (vulnerabilty is null)
                return TypedResults.NotFound("Record doesnot exist");

            var statusAllow = new Dictionary<string, VulnerabilityStatus> {
                { "RESOLVED", VulnerabilityStatus.Resolved }, { "UNRESOLVED", VulnerabilityStatus.UnResolved}
            };
            var status = payload.Status.ToUpper();

            if (!statusAllow.ContainsKey(status))
                return TypedResults.BadRequest("Status can only be Resolved or Unresolved");

            internalVulnerability.EditInternalVulnerabilty(new UpdateActionownerResponse(                
                Classification: payload.Classification,
                Status: statusAllow[status]
            ));

            internalVulnerability.ResetAction();
            internalVulnerability.VulnerabilityModel.SetModifiedBy(currentUserService.CurrentUserFullName);
            internalVulnerability.VulnerabilityModel.SetModifiedOnUtc(DateTime.Now);
            internalVulnerability.VulnerabilityModel.StatusAfterActionOwnerResponse();

            //Remove previous attachment if exist
            docRepo.BulkDelete(x => x.ModuleItemId == payload.InternalVulnerabilityId && x.ModuleItemType == ModuleType.InfoSecInternalVulnerability);
            // Add attachment if available
            if (payload.Attachment != null)
            {
                var evidence = DocumentExtensions.ConvertFormFileToDocument(payload.Attachment, ModuleType.InfoSecInternalVulnerability, payload.InternalVulnerabilityId);
                docRepo.Add(evidence);
            }

            internalRepo.SaveChanges();

            #region Send email to the infosec staff      
            DateTime currentMonth = internalVulnerability.CreatedOnUtc;
            string currentMonthFormatted = currentMonth.ToString("MMMM yyyy");
            string subject = $"Internal Vulnerability Assessment for {currentMonthFormatted} Updated";
            var linkToGRCTool = config["EmailConfiguration:linkToGRCTool"];
            string emailTo = vulnerabilty.RequesterEmailAddress;
            string toCC = $"{currentUserService.CurrentUserEmail}," + config["EmailConfiguration:InformationSecurityGroupEmail"];
            string body = $"Dear {vulnerabilty.CreatedBy}, <br><br>This is to notify you that the remediation has been updated for the {currentMonthFormatted} Internal Vulnerability Assessment. <br><br> The necessary changes have been implemented. Kindly log on here and verify <br><br><a href={linkToGRCTool}>GRC link</a>.";
            var logEmailRequest = await EmailService.LogEmailRequestAssync(subject: subject, message: body, ModuleType.InfoSecInternalVulnerability, vulnerabilty.Id, emailTo, toCC);

            #endregion
            return TypedResults.Ok("Update successful");
        }
    }
}
