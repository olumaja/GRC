using Arm.GrcTool.Domain;
using Arm.GrcTool.Infrastructure;
using GrcApi.Modules.Compliance.CompliancePlanning;
using GrcApi.Modules.Shared.Extensions;
using GrcApi.Modules.Shared.Helpers;
using Microsoft.EntityFrameworkCore;
using static Arm.GrcTool.Domain.RiskEvent.RiskEvent;

namespace Arm.GrcApi.Modules.VulnerabilityManagement
{
    /*
        * Original Author: Sodiq Quadre
        * Date Created: 05/31/2025
        * Development Group: GRCTools
        * Get internal vulnerability by Id Endpoint.
        */
    public class GetInternalVulnerabilityByIdEndpoint
    {
        /// <summary>
        /// Get internal vulnerability by Id Endpoint.
        /// </summary>
        /// <param name="internalVulnerabilityFileId"></param>
        /// <param name="rating"></param>
        /// <param name="impact"></param>
        /// <param name="status"></param>
        /// <param name="classification"></param>
        /// <param name="search"></param>
        /// <param name="docRepo"></param>
        /// <param name="repository"></param>
        /// <param name="vulDetailRepo"></param>
        /// <param name="currentUserService"></param>
        /// <returns></returns>
        public static async Task<IResult> HandleAsync(Guid internalVulnerabilityFileId, string? rating, string? impact, string? status, string? classification, string? search,
            IRepository<Document> docRepo,
            IRepository<VulnerabilityModel> repository,
            IRepository<InternalVulnerability> vulDetailRepo,
            ICurrentUserService currentUserService) 
        {
            try
            {
                var loggedVuln = await repository
                    .GetContextByConditon(r => r.Id == internalVulnerabilityFileId)
                    .FirstOrDefaultAsync();

                if (loggedVuln is null)
                    return TypedResults.NotFound("Record not found");

                var query = vulDetailRepo
                    .GetContextByConditon(v => v.VulnerabilityModelId == loggedVuln.Id);

                if (!string.IsNullOrEmpty(rating))
                {
                    query = query.Where(v => v.Rating == rating);
                }
                if (!string.IsNullOrEmpty(classification))
                {
                    query = query.Where(v => v.Classification == classification);
                }

                if (!string.IsNullOrEmpty(impact))
                {
                    query = query.Where(v => v.Impact == impact);
                }

                if (!string.IsNullOrEmpty(status))
                {
                    var normalizedStatus = status.ToLowerInvariant();
                    var statusMap = new Dictionary<string, VulnerabilityStatus>(StringComparer.OrdinalIgnoreCase)
                    {
                        { "resolved", VulnerabilityStatus.Resolved },
                        { "unresolved", VulnerabilityStatus.UnResolved },
                        { "completed", VulnerabilityStatus.Completed },
                        { "awaiting approval", VulnerabilityStatus.Awaiting_Approval },
                        { "pending", VulnerabilityStatus.Pending }
                    };

                    if (!statusMap.TryGetValue(normalizedStatus, out var mappedStatus))
                        return TypedResults.BadRequest($"Invalid status. Use one of: {string.Join(", ", statusMap.Keys)}");

                    query = query.Where(v => v.Status == mappedStatus);
                }

                if (!string.IsNullOrEmpty(search))
                {
                    query = query.Where(v =>
                        v.CreatedBy.Contains(search) ||
                        v.IP.Contains(search) ||
                        v.Impact.Contains(search) ||
                        v.ModifiedBy.Contains(search) ||
                        v.DNS.Contains(search) ||
                        v.NETBIOS.Contains(search) ||
                        v.Classification.Contains(search) ||
                        v.Comment.Contains(search) ||
                        v.Port.Contains(search) ||
                        v.Proptocol.Contains(search) ||
                        v.Threat.Contains(search) ||
                        v.ReClassification.Contains(search) ||
                        v.Rating.Contains(search) ||
                        v.Solution.Contains(search));
                }

                var vulnerabilities = await query.ToListAsync();
                var responseList = new List<GetInternalVulnerabilityById>();

                foreach (var vuln in vulnerabilities)
                {
                    var attachments = await docRepo
                        .GetContextByConditon(d =>
                            d.ModuleItemId == vuln.Id &&
                            d.ModuleItemType == ModuleType.InfoSecInternalVulnerability)
                        .Select(d => new GetAttachedReportResponse
                        {
                            DocumentId = d.Id,
                            DateCreated = d.CreatedOnUtc,
                            DocumentName = d.Name
                        })
                        .ToListAsync();

                    responseList.Add(new GetInternalVulnerabilityById
                    {
                        InternalVulnerabilityId = vuln.Id,
                        IP = vuln.IP,
                        DNS = vuln.DNS,
                        NETBIOS = vuln.NETBIOS,
                        Vulnerability = vuln.Vulnerability,
                        Rating = vuln.Rating,
                        Port = vuln.Port,
                        Protocol = vuln.Proptocol,
                        Threat = vuln.Threat,
                        Impact = vuln.Impact,
                        Solution = vuln.Solution,
                        Classification = vuln.Classification,
                        Comment = vuln.Comment,
                        Status = vuln.Status.ToString(),
                        Action = vuln.Action.ToString(),
                        Evidence = attachments
                    });
                }

                var result = new GetInternalVulnerabilityByIdDetail(
                    InternalVulnerabilityFileId: internalVulnerabilityFileId,
                    AssessmentType: loggedVuln.AssessmentType,
                    DocumentTitle: loggedVuln.TitleOfAssessment,
                    RequestedBy: loggedVuln.CreatedBy,
                    ActionOwner: loggedVuln.ActionOwner,
                    ActionOwnerEmail: loggedVuln.ActionOwnerEmail,
                    ActionOwnerUnit: loggedVuln.ActionOwnerUnit,
                    ProposeEndDate: loggedVuln.ProposeEndDate,
                    ApprovedBy: loggedVuln.ApprovedBy,
                    DateApproved: loggedVuln.DateApproved,
                    RequestedDate: loggedVuln.CreatedOnUtc,
                    Status: loggedVuln.VulnerabilityStatus.ToString(),
                    InternalVulnerabilities: responseList
                );

                return TypedResults.Ok(result);
            }
            catch (Exception ex)
            {
                return TypedResults.Problem("Unable to get the vulnerability detail");
            }
        }



    }
}
