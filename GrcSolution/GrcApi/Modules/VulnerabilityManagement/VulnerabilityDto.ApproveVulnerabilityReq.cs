using Arm.GrcApi.Modules.Shared;
using FluentValidation;
using GrcApi.Modules.Shared.Helpers;

namespace Arm.GrcApi.Modules.VulnerabilityManagement
{
    public record ApproveRejectDto(Guid VulnerabiltyFileId, List<ApproveVulnerabilityReq> VulnerabilityDetails);
    public record ApproveVulnerabilityReq(
        Guid InternalVulnerabilityId, string ActionStatus, string ReasonForRejection
    );

    public class ApproveVulnerabilityReqValidator : AbstractValidator<ApproveVulnerabilityReq>
    {
        public ApproveVulnerabilityReqValidator()
        {
            RuleFor(x => x.InternalVulnerabilityId).NotEmpty();
        }
    }

    public record ApproveVulnerabilityRequest(
       Guid InternalVulnerabilityId
   );

    public class ApproveVulnerabilityRequestValidator : AbstractValidator<ApproveVulnerabilityRequest>
    {
        public ApproveVulnerabilityRequestValidator()
        {
            RuleFor(x => x.InternalVulnerabilityId).NotEmpty();
        }
    }

    public record RejectVulnerabilityReq(
      Guid InternalVulnerabilityId,
      string Comment
   );

    public class RejectVulnerabilityReqValidator : AbstractValidator<RejectVulnerabilityReq>
    {
        public RejectVulnerabilityReqValidator()
        {
            RuleFor(x => x.InternalVulnerabilityId).NotEmpty();
            RuleFor(x => x.Comment).NotEmpty().Must(CharacterValidation.IsInvalidCharacter).WithMessage(GRCToolsMessages.InvalidCharacters);

        }
    }

    public record SubmitVulnerabiltyModelDt0(Guid vulnerabilityModelId);

    public class SubmitVulnerabiltyModelDt0alidator : AbstractValidator<SubmitVulnerabiltyModelDt0>
    {
        public SubmitVulnerabiltyModelDt0alidator()
        {
            RuleFor(x => x.vulnerabilityModelId).NotEmpty();

        }
    }
}
